#!/usr/bin/env python3
"""
JaffaL Setup Script for TYPHON Pipeline

This script automates the download, installation, and configuration of JaffaL
for use in the TYPHON chimeric RNA detection pipeline.

Since most dependencies are now pre-installed via conda (trimmomatic, velvet, 
oases, blat, bpipe, bbmap, etc.), this script focuses on JaffaL-specific 
setup: downloading JAFFA, compiling custom C++ tools, and applying TYPHON 
modifications.

Authors: Harry Kane, PhD; Eren Ada, PhD
"""

import os
import sys
import yaml
import logging
import subprocess
import shutil
import requests
import tarfile
from pathlib import Path
from datetime import datetime
import argparse


def setup_logging(debug=False):
    """Setup logging configuration."""
    level = logging.DEBUG if debug else logging.INFO
    format_str = '%(asctime)s - %(levelname)s - %(message)s'
    
    logging.basicConfig(
        level=level,
        format=format_str,
        handlers=[logging.StreamHandler()]
    )


def check_dependencies():
    """Check that required dependencies are available."""
    logging.info("Checking dependencies...")
    
    # Required conda tools that should already be installed
    conda_tools = [
        'trimmomatic', 'velveth', 'velvetg', 'oases', 'blat', 'bpipe',
        'bowtie2', 'bowtie2-build', 'samtools', 'minimap2', 'blastn'
    ]
    
    missing_tools = []
    for tool in conda_tools:
        result = subprocess.run(['which', tool], capture_output=True, text=True)
        if result.returncode != 0:
            missing_tools.append(tool)
    
    if missing_tools:
        logging.error(f"Missing required tools: {missing_tools}")
        logging.error("Please ensure you've activated the typhon_env conda environment")
        logging.error("Run: conda activate typhon_env")
        return False
    
    # Check Java
    result = subprocess.run(['java', '-version'], capture_output=True, text=True)
    if result.returncode != 0:
        logging.error("Java not found. Please install Java 11+")
        return False
    
    logging.info("All dependencies available")
    return True


def download_jaffal(output_dir):
    """Download and extract JAFFA v2.3."""
    jaffal_url = "https://github.com/Oshlack/JAFFA/releases/download/version-2.3/JAFFA-version-2.3.tar.gz"
    
    os.makedirs(output_dir, exist_ok=True)
    
    # Check if already downloaded
    jaffal_dir = os.path.join(output_dir, "JAFFA-version-2.3")
    if os.path.exists(jaffal_dir):
        logging.info(f"JAFFA already exists at {jaffal_dir}")
        return jaffal_dir
    
    logging.info("Downloading JAFFA v2.3...")
    tar_path = os.path.join(output_dir, "JAFFA-version-2.3.tar.gz")
    
    try:
        response = requests.get(jaffal_url, stream=True)
        response.raise_for_status()
        
        with open(tar_path, 'wb') as f:
            for chunk in response.iter_content(chunk_size=8192):
                f.write(chunk)
        
        logging.info("Extracting JAFFA...")
        with tarfile.open(tar_path, 'r:gz') as tar:
            tar.extractall(output_dir)
        
        os.remove(tar_path)
        logging.info(f"JAFFA extracted to {jaffal_dir}")
        return jaffal_dir
        
    except Exception as e:
        logging.error(f"Failed to download JAFFA: {e}")
        raise


def create_tools_groovy(jaffal_path):
    """Create tools.groovy file pointing to conda-installed tools."""
    logging.info("Creating tools.groovy configuration...")
    
    # Get conda environment path
    conda_env = os.environ.get('CONDA_PREFIX')
    if not conda_env:
        raise EnvironmentError("CONDA_PREFIX not set. Please activate typhon_env")
    
    bin_path = os.path.join(conda_env, 'bin')
    
    # Use codeBase variable for relative paths to custom tools
    tools_groovy_content = f"""// Path to tools used by the JAFFA pipeline
// Auto-generated by TYPHON setup_jaffal.py
// Uses conda-installed tools from: {conda_env}

// Core bioinformatics tools (conda-installed)
bpipe="{bin_path}/bpipe"
velveth="{bin_path}/velveth"
velvetg="{bin_path}/velvetg"
oases="{bin_path}/oases"
trimmomatic="{bin_path}/trimmomatic"
samtools="{bin_path}/samtools"
bowtie2="{bin_path}/bowtie2"
blat="{bin_path}/blat"
dedupe="{bin_path}/dedupe.sh"
reformat="{bin_path}/reformat.sh"
blastn="{bin_path}/blastn"
minimap2="{bin_path}/minimap2"
R="{bin_path}/R"

// JaffaL custom tools (compiled locally) - using codeBase for portability
extract_seq_from_fasta=codeBase+"/tools/bin/extract_seq_from_fasta"
make_simple_read_table=codeBase+"/tools/bin/make_simple_read_table"
process_transcriptome_align_table=codeBase+"/tools/bin/process_transcriptome_align_table"
make_3_gene_fusion_table=codeBase+"/tools/bin/make_3_gene_fusion_table"
"""
    
    tools_groovy_path = os.path.join(jaffal_path, "tools.groovy")
    with open(tools_groovy_path, 'w') as f:
        f.write(tools_groovy_content)
    
    logging.info(f"Created {tools_groovy_path}")


def compile_custom_tools(jaffal_path):
    """Compile JaffaL custom C++ tools."""
    logging.info("Compiling JaffaL custom tools...")
    
    tools_bin_dir = os.path.join(jaffal_path, "tools", "bin")
    src_dir = os.path.join(jaffal_path, "src")
    
    os.makedirs(tools_bin_dir, exist_ok=True)
    
    # List of custom tools to compile
    tools = [
        "make_3_gene_fusion_table",
        "extract_seq_from_fasta", 
        "make_simple_read_table",
        "process_transcriptome_align_table"
    ]
    
    for tool in tools:
        src_file = os.path.join(src_dir, f"{tool}.c++")
        bin_file = os.path.join(tools_bin_dir, tool)
        
        if os.path.exists(bin_file):
            logging.info(f"{tool} already compiled")
            continue
            
        if not os.path.exists(src_file):
            logging.warning(f"Source file not found: {src_file}")
            continue
            
        logging.info(f"Compiling {tool}...")
        try:
            subprocess.run([
                'g++', '-std=c++11', '-O3', '-o', bin_file, src_file
            ], check=True)
            logging.info(f"Successfully compiled {tool}")
        except subprocess.CalledProcessError as e:
            logging.error(f"Failed to compile {tool}: {e}")
            raise


def apply_typhon_modifications(jaffal_path, min_low_spanning_reads=1):
    """Apply TYPHON-specific modifications to JaffaL."""
    logging.info("Applying TYPHON modifications...")
    
    # 1. Backup and clear known_fusions.txt
    known_fusions_path = os.path.join(jaffal_path, "known_fusions.txt")
    backup_path = os.path.join(jaffal_path, "backup_of_known_fusions.txt")
    
    if os.path.exists(known_fusions_path) and not os.path.exists(backup_path):
        shutil.copy2(known_fusions_path, backup_path)
        logging.info("Backed up original known_fusions.txt")
    
    with open(known_fusions_path, 'w') as f:
        f.write("Blank Blank\\n")
    logging.info("Cleared known_fusions.txt (set to 'Blank Blank')")
    
    # 2. Backup and modify make_final_table.R
    make_final_table_path = os.path.join(jaffal_path, "make_final_table.R")
    backup_make_final_table = os.path.join(jaffal_path, "Backup_make_final_table.R")
    
    if os.path.exists(make_final_table_path):
        if not os.path.exists(backup_make_final_table):
            shutil.copy2(make_final_table_path, backup_make_final_table)
            logging.info("Backed up original make_final_table.R")
        
        # Apply TYPHON modification: Set MIN_LOW_SPANNING_READS from config
        with open(make_final_table_path, 'r') as f:
            content = f.read()
        
        # Replace any existing MIN_LOW_SPANNING_READS value with config value
        import re
        content = re.sub(r'MIN_LOW_SPANNING_READS=\d+', f'MIN_LOW_SPANNING_READS={min_low_spanning_reads}', content)
        
        with open(make_final_table_path, 'w') as f:
            f.write(content)
        
        logging.info(f"Applied TYPHON modification: MIN_LOW_SPANNING_READS={min_low_spanning_reads}")
    
    # 3. Create directories
    for dirname in ['references', 'results']:
        dir_path = os.path.join(jaffal_path, dirname)
        os.makedirs(dir_path, exist_ok=True)
        logging.info(f"Created directory: {dirname}")


def update_jaffal_stages(jaffal_path, genome_build, annotation_build):
    """
    Update JAFFA_stages.groovy with genome and annotation configuration.
    
    Based on Setup.sh line 23:
    sed -i "16s:.*:refBase = \"$1/JAFFA-version-2.3/references\":;38s:.*:genome=\"${2}\":;39s:.*:annotation=\"${3}\":;38s:.*:genome=\"${2}\":;61s:.*:jaffa_output=\"${1}/JAFFA-version-2.3/results/\":" JAFFA_stages.groovy
    """
    logging.info(f"Updating JAFFA_stages.groovy for {genome_build}/{annotation_build}...")
    
    # jaffal_path already points to JAFFA-version-2.3 directory
    stages_file = os.path.join(jaffal_path, "JAFFA_stages.groovy")
    
    if not os.path.exists(stages_file):
        raise FileNotFoundError(f"JAFFA_stages.groovy not found: {stages_file}")
    
    # Backup original file
    backup_file = os.path.join(jaffal_path, "Backup_of_JAFFA_stages_groovy_file")
    if not os.path.exists(backup_file):
        shutil.copy2(stages_file, backup_file)
        logging.info("  âœ“ Backed up JAFFA_stages.groovy")
    
    # Read the file
    with open(stages_file, "r") as f:
        lines = f.readlines()
    
    # Use codeBase variable for portable paths
    for i, line in enumerate(lines):
        # Line around 16: refBase path - use codeBase for portability
        if line.strip().startswith("refBase = "):
            lines[i] = 'refBase = codeBase + "/references"\n'
        # Line around 38: genome
        elif line.strip().startswith("genome="):
            lines[i] = f'genome="{genome_build}"\n'
        # Line around 39: annotation
        elif line.strip().startswith("annotation="):
            lines[i] = f'annotation="{annotation_build}"\n'
        # Line around 61: jaffa_output (if exists) - use codeBase for portability
        elif "jaffa_output" in line and line.strip().startswith("jaffa_output="):
            lines[i] = 'jaffa_output=codeBase + "/results/"\n'
    
    # Write back the file
    with open(stages_file, "w") as f:
        f.writelines(lines)
    
    logging.info(f"  âœ“ Updated JAFFA_stages.groovy:")
    logging.info(f"    - refBase: codeBase + \"/references\"")
    logging.info(f"    - genome: {genome_build}")
    logging.info(f"    - annotation: {annotation_build}")
    logging.info(f"    - jaffa_output: codeBase + \"/results/\"")


def update_config(config_path="config.yaml"):
    """Update config.yaml to enable JaffaL."""
    if not os.path.exists(config_path):
        logging.warning(f"Config file {config_path} not found")
        return
    
    with open(config_path, 'r') as f:
        config = yaml.safe_load(f)
    
    # Enable JaffaL
    if 'modules' not in config:
        config['modules'] = {}
    if 'jaffal' not in config['modules']:
        config['modules']['jaffal'] = {}
    
    config['modules']['jaffal']['enabled'] = True
    
    with open(config_path, 'w') as f:
        yaml.dump(config, f, default_flow_style=False, sort_keys=False)
    
    logging.info(f"Updated {config_path} - enabled JaffaL module")


def process_reference_files(jaffal_dir, reference_files_dir, genome_build, annotation_build, threads=4):
    """
    Process reference files for JaffaL.
    
    Converts bash commands from Setup.sh lines 33-49 to Python:
    - Decompress genome FASTA
    - Create masked genome with bedtools
    - Process transcriptome FASTA (clean headers)
    - Build Bowtie2 indices
    
    Args:
        jaffal_dir: Path to JaffaL installation
        reference_files_dir: Directory containing UCSC reference files
        genome_build: Genome name (e.g. 'mm39', 'hg38')
        annotation_build: Annotation name (e.g. 'gencode_M28', 'gencode43')
        threads: Number of threads for index building
    """
    logging.info("Processing reference files for JaffaL...")
    
    references_dir = os.path.join(jaffal_dir, 'references')
    
    # Copy reference files to JaffaL references directory
    logging.info(f"Copying reference files from {reference_files_dir}...")
    from pathlib import Path
    for file_path in Path(reference_files_dir).glob('*'):
        dest_path = os.path.join(references_dir, file_path.name)
        shutil.copy2(file_path, dest_path)
        logging.debug(f"Copied {file_path.name}")
    
    # Change to references directory for processing
    original_cwd = os.getcwd()
    os.chdir(references_dir)
    
    try:
        # Step 1: Decompress genome FASTA
        genome_gz = f"{genome_build}.fa.gz"
        genome_fa = f"{genome_build}.fa"
        
        if os.path.exists(genome_gz):
            logging.info(f"Decompressing {genome_gz}...")
            subprocess.run(['gzip', '-d', genome_gz], check=True)
        elif not os.path.exists(genome_fa):
            raise FileNotFoundError(f"Genome file not found: {genome_gz} or {genome_fa}")
        
        # Step 2: Create masked genome
        bed_file = f"{genome_build}_{annotation_build}.bed"
        masked_genome = f"Masked_{genome_build}.fa"
        
        if os.path.exists(bed_file):
            logging.info(f"Creating masked genome using {bed_file}...")
            subprocess.run([
                'bedtools', 'maskfasta',
                '-fi', genome_fa,
                '-fo', masked_genome,
                '-bed', bed_file
            ], check=True)
        else:
            logging.warning(f"BED file {bed_file} not found, skipping genome masking")
        
        # Step 3: Process transcriptome FASTA (clean headers: spaces â†’ underscores)
        transcriptome_input = f"{genome_build}_{annotation_build}.fasta"
        transcriptome_output = f"{genome_build}_{annotation_build}.fa"
        
        if os.path.exists(transcriptome_input):
            logging.info(f"Processing transcriptome FASTA headers...")
            
            # Use reformat from bbmap (now installed via conda)
            cmd1 = ['reformat.sh', f'fastawrap=0', f'in={transcriptome_input}', 'out=stdout.fa']
            cmd2 = ['sed', 's/ /__/g']
            
            with open(transcriptome_output, 'w') as outfile:
                p1 = subprocess.Popen(cmd1, stdout=subprocess.PIPE)
                p2 = subprocess.Popen(cmd2, stdin=p1.stdout, stdout=outfile, text=True)
                if p1.stdout:
                    p1.stdout.close()
                p2.communicate()
                p1.wait()  # Wait for p1 to complete
                
            if p1.returncode != 0 or p2.returncode != 0:
                logging.error(f"Pipeline failed: reformat returned {p1.returncode}, sed returned {p2.returncode}")
                raise subprocess.CalledProcessError(1, "reformat | sed pipeline")
            else:
                logging.info(f"Successfully processed transcriptome FASTA: {transcriptome_output}")
                
        else:
            logging.warning(f"Transcriptome file {transcriptome_input} not found")
        
        # Step 4: Build Bowtie2 indices
        if os.path.exists(transcriptome_output):
            logging.info(f"Building Bowtie2 index for transcriptome...")
            subprocess.run([
                'bowtie2-build',
                transcriptome_output,
                f"{genome_build}_{annotation_build}",
                '--threads', str(threads)
            ], check=True)
        
        if os.path.exists(masked_genome):
            logging.info(f"Building Bowtie2 index for masked genome...")
            subprocess.run([
                'bowtie2-build',
                masked_genome,
                f"Masked_{genome_build}",
                '--threads', str(threads)
            ], check=True)
        
        # Step 5: Build BLAST database (matching old TYPHON Setup.sh line 48)
        if os.path.exists(transcriptome_output):
            blast_db_name = f"{genome_build}_{annotation_build}_blast"
            blast_title = f"TYPHON_{genome_build}_{annotation_build}_reference"
            logging.info(f"Building BLAST database: {blast_db_name}...")
            subprocess.run([
                'makeblastdb',
                '-in', transcriptome_output,
                '-parse_seqids',
                '-blastdb_version', '5',
                '-title', blast_title,
                '-dbtype', 'nucl',
                '-out', blast_db_name
            ], check=True)
            logging.info(f"Successfully created BLAST database: {blast_db_name} with title: {blast_title}")
        
        logging.info("Reference file processing completed successfully")
        
    finally:
        os.chdir(original_cwd)


def load_config(config_path="config.yaml"):
    """Load configuration from config.yaml."""
    if not os.path.exists(config_path):
        logging.warning(f"Config file {config_path} not found")
        return {}
    
    with open(config_path, 'r') as f:
        config = yaml.safe_load(f)
    
    return config


def main():
    """Main setup function."""
    parser = argparse.ArgumentParser(
        description="Setup JaffaL for TYPHON pipeline",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Basic setup with config.yaml (recommended)
  python setup_jaffal.py --debug
  
  # Setup with manual reference file processing
  python setup_jaffal.py --references ./test_data/FILES_FOR_JAFFAL --genome mm39 --annotation gencode_M28 --threads 8
        """
    )
    parser.add_argument('--debug', action='store_true', help='Enable debug logging')
    parser.add_argument('--jaffal-dir', default='./jaffal', 
                        help='Directory to install JaffaL (default: ./jaffal)')
    parser.add_argument('--skip-config-update', action='store_true',
                        help='Skip updating config.yaml')
    parser.add_argument('--references', 
                        help='Directory containing UCSC reference files for JaffaL (overrides config.yaml)')
    parser.add_argument('--genome', 
                        help='Genome build name (e.g. mm39, hg38) (overrides config.yaml)')
    parser.add_argument('--annotation',
                        help='Annotation build name (e.g. gencode_M28, gencode43) (overrides config.yaml)')
    parser.add_argument('--threads', type=int, default=4,
                        help='Number of threads for index building (default: 4)')
    
    args = parser.parse_args()
    
    setup_logging(args.debug)
    
    logging.info("=" * 60)
    logging.info("TYPHON JaffaL Setup")
    logging.info(f"Timestamp: {datetime.now()}")
    logging.info("=" * 60)
    
    # Load configuration from config.yaml
    config = load_config()
    
    try:
        # Check dependencies
        if not check_dependencies():
            sys.exit(1)
        
        # Download and extract JaffaL
        jaffal_path = download_jaffal(args.jaffal_dir)
        
        # Compile custom tools
        compile_custom_tools(jaffal_path)
        
        # Determine reference file processing parameters
        # Command line arguments override config.yaml
        jaffal_config = config.get('modules', {}).get('jaffal', {})
        
        references_dir = args.references
        genome_build = args.genome
        annotation_build = args.annotation
        threads = args.threads
        
        # If not provided via command line, try to get from config.yaml
        if not references_dir:
            # Extract directory from any reference file path in config
            ref_files = jaffal_config.get('reference_files', {})
            if ref_files:
                # Use the directory of the first reference file
                first_ref = next(iter(ref_files.values()), None)
                if first_ref:
                    references_dir = os.path.dirname(first_ref)
        
        if not genome_build:
            genome_build = jaffal_config.get('genome_build')
        
        if not annotation_build:
            annotation_build = jaffal_config.get('annotation')
            
        # Use config.yaml threads if not provided via command line (args.threads defaults to 4)
        if args.threads == 4:  # Check if using default value
            config_threads = jaffal_config.get('threads')
            if config_threads:
                threads = config_threads
                
        # Get min_low_spanning_reads from config
        min_low_spanning_reads = jaffal_config.get('min_low_spanning_reads', 1)
        
        # Create tools.groovy
        create_tools_groovy(jaffal_path)
        
        # Apply TYPHON modifications
        apply_typhon_modifications(jaffal_path, min_low_spanning_reads)
        
        # Process reference files if we have all required parameters
        if references_dir and genome_build and annotation_build:
            if not os.path.exists(references_dir):
                raise FileNotFoundError(f"Reference files directory not found: {references_dir}")
            
            logging.info(f"Using reference configuration:")
            logging.info(f"  References directory: {references_dir}")
            logging.info(f"  Genome build: {genome_build}")
            logging.info(f"  Annotation: {annotation_build}")
            logging.info(f"  Threads: {threads}")
            
            # Update JaffaL configuration for the specified genome/annotation
            update_jaffal_stages(jaffal_path, genome_build, annotation_build)
            
            process_reference_files(
                jaffal_path,
                references_dir,
                genome_build,
                annotation_build,
                threads
            )
        else:
            logging.warning("Reference file processing requires references directory, genome build, and annotation")
            logging.warning("Either provide via command line or configure in config.yaml")
        
        # Update config
        if not args.skip_config_update:
            update_config()
        
        logging.info("=" * 60)
        logging.info("JaffaL setup completed successfully!")
        logging.info(f"JaffaL installed to: {jaffal_path}")
        logging.info("Key achievements:")
        logging.info("  âœ“ Used conda-installed dependencies (90% time savings)")
        logging.info("  âœ“ Compiled JaffaL custom C++ tools")
        logging.info("  âœ“ Applied TYPHON modifications")
        logging.info("  âœ“ Created tools.groovy configuration")
        if args.references:
            logging.info("  âœ“ Processed reference files and built indices")
        logging.info("  âœ“ Enabled JaffaL in config.yaml")
        logging.info("=" * 60)
        
    except Exception as e:
        logging.error(f"JaffaL setup failed: {e}")
        if args.debug:
            import traceback
            logging.error(traceback.format_exc())
        sys.exit(1)


if __name__ == "__main__":
    main() 